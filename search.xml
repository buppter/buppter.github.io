<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[SQLAchemy中处理两张表之间存在多个外键的情况]]></title>
    <url>%2F2019%2F01%2F24%2FSQLAchemy%E4%B8%AD%E5%A4%84%E7%90%86%E4%B8%A4%E5%BC%A0%E8%A1%A8%E4%B9%8B%E9%97%B4%E5%AD%98%E5%9C%A8%E5%A4%9A%E4%B8%AA%E5%A4%96%E9%94%AE%E7%9A%84%E6%83%85%E5%86%B5%2F</url>
    <content type="text"><![CDATA[在Flask的开发中，我们势必会遇到两张表之间存在多个外键的情况。例如，现在有两张表，一张表是User，另一张表是Article。一篇文章的作者author_id可以设置外键关联User表，同时文章的审稿人reviewer_id也可以设置外键关联User表。当我们以SQLAchemy多对一(many to one)的设计方法来添加relationship关系映射时，程序会抛出一个AmbiguousForeignKeysError错误，这篇文章我们就来解决这个问题。出现Error的代码写法先来看以SQLAchemy多对一的常规设计方法处理这个问题时我的代码写法。12345678910111213141516171819from flask_sqlalchemy import SQLAlchemydb = SQLAlchemy()class User(db.Model): __tablename__ = 'users' id = db.Column(db.Integer, primary_key=True) email = db.Column(db.String(64), nullable=False, unique=True) name = db.Column(db.String(32), nullable=False) ... class Article(db.Model): __tablename__ = 'articles' id = db.Column(db.Integer, primary_key=True) title = db.Column(db.String(64), nullable=False) author_id = db.Column(db.Integer, db.ForeignKey("users.id")) reviewer_id = db.Column(db.Integer, db.ForeignKey("users.id")) author = db.relationship('User', backref='articles') reviewer = db.relationship('User', backref='review_articles')看起来程序的设计应该是没问题，可运行的结果真的跟我们预想的一样吗？当我们运行代码后，程序抛出了一个错误：12345sqlalchemy.exc.AmbiguousForeignKeysError: Could not determine join condition between parent/child tables on relationship Article.author - there are multiple foreign key paths linking the tables. Specify the &apos;foreign_keys&apos; argument, providing a list of those columns which should be counted as containing a foreign key reference to the parent table.可以看到SQLAchemy提示无法确定Article.author的父子表之间的关联，原因在于两张表之间存在多个外键。需要我们指定foreign_keys参数，提供一个包含关联了父表（即User表）外键的字段列表（list)解决办法查询了很多博客资料后这个问题依旧没有得到解决，只好去阅读SQLAchemy的官方文档，在SQLAchemy ORM &gt; Relationship Configuation &gt; Configuring how Relationship Joins下有关于Handling Multiple Join Paths的介绍。文档中说，在遇到两表之间存在多外键关联时，需要给relationship()指定foreign_keys参数。需要对我们的代码进行修改，添加foreign_keys参数，所以将代码修改为：12345678910111213141516171819202122232425from flask_sqlalchemy import SQLAlchemydb = SQLAlchemy()class User(db.Model): __tablename__ = 'users' id = db.Column(db.Integer, primary_key=True) email = db.Column(db.String(64), nullable=False, unique=True) name = db.Column(db.String(32), nullable=False) ... def __repr__(self): return '&lt;User id=&#123;0&#125;, name=&#123;1&#125;&gt;'.format(self.id, self.name) class Article(db.Model): __tablename__ = 'articles' id = db.Column(db.Integer, primary_key=True) title = db.Column(db.String(64), nullable=False) author_id = db.Column(db.Integer, db.ForeignKey("users.id")) reviewer_id = db.Column(db.Integer, db.ForeignKey("users.id")) author = db.relationship('User', backref='articles', foreign_keys=[author_id]) reviewer = db.relationship('User', backref='review_articles', foreign_keys=[reviewer_id]) def __repr__(self): return '&lt;Article id=&#123;0&#125;, title=&#123;1&#125;&gt;'.format(self.id, self.title)同时，在指定foreign_keys时，我们也可以使用字符串来指定。但如果使用列表，则列表必须是字符串的一部分。1author = db.relationship('User', backref='articles', foreign_keys="[author_id]")在我们这个具体的例子中，不需要列表，所以可以写成：1author = db.relationship('User', backref='articles', foreign_keys="author_id")测试在修改过后，我们运行程序，测试一下代码我们先给User表添加两条数据1234&gt;&gt;&gt; zhangsan = User(email=&apos;zhangsan@123.com&apos;, name=&apos;张三&apos;)&gt;&gt;&gt; lisi = User(emaill=&apos;lisi@123.com&apos;, name=&apos;李四&apos;)&gt;&gt;&gt; db.session.add_all([zhangsan,lisi])&gt;&gt;&gt; db.session.commit()接着给Article表添加一条记录，指定Author为张三(users.id=1)，Reviewer为李四(usersid)123456&gt;&gt;&gt; article = Article()&gt;&gt;&gt; article.title = &quot;Test&quot;&gt;&gt;&gt; article.author_id = 1&gt;&gt;&gt; article.reviewer_id = 2&gt;&gt;&gt; db.session.add(article)&gt;&gt;&gt; db.session.commit()我们来做查询操作1234567&gt;&gt;&gt; article = Article.query.get(1)&gt;&gt;&gt; article&lt;Article id=1, title=Test&gt;&gt;&gt;&gt; article.author&lt;User id=1, name=张三&gt;&gt;&gt;&gt; article.reviewer&lt;User id=2, name=李四&gt;可以看到我们可以正确的查询到article.author和article.reviewer，关于SQLAchemy中处理两张表之间存在多个外键的情况这个问题我们已经解决。扩展在relationship()中我们添加了backref参数来对关系提供反向引用，这样更加方便了我们的查询操作。示例：1234567&gt;&gt;&gt; zhangsan = User.query.filter_by(name=&apos;张三&apos;).first()&gt;&gt;&gt; zhangsan&lt;User id=1, name=张三&gt;&gt;&gt;&gt; zhangsan.articles[&lt;Article id=1, title=Test&gt;]&gt;&gt;&gt; zhangsan.review_articles[]因为我们给artice.author添加了articles的反向引用，给article.reviewer添加了review_articles的反向引用。所以对于User 张三来说，他是article Test的Author，可以通过article.author来查询得到张三。也可以通过zhangsan.articles反向查询得到Test这篇文章。同时，因为张三不是任何一篇文章的reviewer，所以通过zhangsan.review_articles查询到结果为空列表。同样的，我们来看李四的查询操作：1234567&gt;&gt;&gt; lisi = User.query.filter_by(name=&apos;李四&apos;).first()&gt;&gt;&gt; lisi&lt;User id=2, name=李四&gt;&gt;&gt;&gt; lisi.articles[]&gt;&gt;&gt; lisi.review_articles[&lt;Article id=1, title=Test&gt;]结果其实跟张三的查询是类似的，只是两人的角色author和reviewer不同，这里不再啰嗦。]]></content>
      <categories>
        <category>Flask</category>
      </categories>
      <tags>
        <tag>Flask</tag>
        <tag>Flask-SQLAchemy</tag>
        <tag>SQLAchemy</tag>
      </tags>
  </entry>
</search>
